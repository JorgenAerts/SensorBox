
/*
Code for DHT sensor adapted from: https://wiki.dfrobot.com/DHT22_Temperature_and_humidity_module_SKU_SEN0137 19-11-2024
Code for Async Webserver adapted from: https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library/ 19-11-2024
Code for OTA adapted from : https://randomnerdtutorials.com/esp32-ota-over-the-air-arduino/ 19-11-2024
Code for MQTT adapted from a ChatGPT query for the MQTT excercises: ChatGPT; GPT-4. OpenAI, 2023. https://openai.com/chatgpt 19-11-2024
Code correction and Webserver html by ChatGPT:  ChatGPT. GPT-4. OpenAI, 2023. https://openai.com/chatgpt.  19-11-2024
Code correction remote button: Claude Ai; Anthropic AI https://claude.ai 21-11-2024
Bluetooth characteristics: 
https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml 25-11-2024
Extra UUID's generated by: https://www.uuidgenerator.net/ 25-11-2024
Bluetooth code adapted from: https://randomnerdtutorials.com/esp32-web-bluetooth/ 25-11-2024

Updates 25-11-2024:
-------------------
Spelling in comments
Moved html code to separate header html.h, and added a style block to it for some subtle changes.
Add Low energy bluetooth functionality.
Running both bluetooth and WiFi will be too much for the esp32, so BLE is commented out.
*/

// Libraries
#include <Arduino.h>
#include <DHT.h>
#include <Adafruit_Sensor.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ElegantOTA.h>
#include <WiFi.h>
#include <PubSubClient.h>
#include <html.h>
#include <secrets.h>
// #include <BLEDevice.h>
// #include <BLEServer.h>
// #include <BLEUtils.h>
// #include <BLE2902.h>

// LED's
#define ledRedLum 25
#define ledRedTemp 26
#define ledRedHum 14
#define ledGreenLum 13
#define ledGreenTemp 21
#define ledGreenHum 22

// Lightsensor
#define ldrSensor 36
int lum = 0;
unsigned long previousMillisLdr = 0;
const long intervalLdr = 5000;

// DHT 22 sensor
#define DHTPIN 16
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);
float hum;
float temp;
unsigned long previousMillisDht = 0;
const long intervalDht = 5000;

// LED test button
#define button 19
unsigned long previousMillisTestActive = 0;
const long testActive = 2000;
bool ledTestActive = false;

// WebServer
AsyncWebServer server(80);

// MQTT
WiFiClient espClient;
PubSubClient client(espClient);
const char *mqtt_server = "10.6.121.204"; //  IP address of the MQTT broker, a Raspberry Pi in this case
const int mqtt_port = 1883;               // broker port (default is 1883)
// MQTT Topics
const char *temperatureTopic = "home/sensor/temperature";
const char *humidityTopic = "home/sensor/humidity";
const char *luminosityTopic = "home/sensor/luminosity";

// //  Bluetooth
// BLEServer *pServer = NULL;
// BLECharacteristic *pSensorCharacteristic1 = NULL;
// BLECharacteristic *pSensorCharacteristic2 = NULL;
// BLECharacteristic *pSensorCharacteristic3 = NULL;
// BLECharacteristic *pWritableCharacteristic1 = NULL;
// bool deviceConnected = false;
// bool oldDeviceConnected = false;

// #define SERVICE_UUID "19b10000-e8f2-537e-4f6c-d104768a1214"
// #define SENSOR_CHARACTERISTIC_UUID1 "19b10001-e8f2-537e-4f6c-d104768a1214"
// #define SENSOR_CHARACTERISTIC_UUID2 "34de371c-ca75-4151-b3af-2c2d74f01a0f"
// #define SENSOR_CHARACTERISTIC_UUID3 "4ebde681-8e95-4263-b9fb-7fc4030da492"
// #define WRITABLE_CHARACTERISTIC_UUID1 "081ff2b0-309b-4ade-aa8f-8611ebe0d8eb"

// class MyServerCallbacks : public BLEServerCallbacks
// {
//     void onConnect(BLEServer *pServer)
//     {
//         deviceConnected = true;
//     };

//     void onDisconnect(BLEServer *pServer)
//     {
//         deviceConnected = false;
//     }
// };

// class MyCallbacks : public BLECharacteristicCallbacks
// {
//     void onWrite(BLECharacteristic *pCharacteristic)
//     {
//         std::string value = pCharacteristic->getValue();
//         if (value == "1")
//             std::string value = pCharacteristic->getValue();
//         if (value.length() > 0)
//         {
//             Serial.println("Received data from web app:");
//             for (int i = 0; i < value.length(); i++)
//             {
//                 Serial.print(value[i]);
//             }
//             Serial.println();
//         }
//     }
// };

// Connect to Wi-Fi
void connectWifi()
{
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.println("Connecting to WiFi..");
    }
    Serial.println("Connected to WiFi");
    Serial.print("ESP32 IP Address: ");
    Serial.println(WiFi.localIP()); // Print the IP address
}

// Connect to the MQTT broker
void connectToMQTT()
{
    while (client.connected() == false)
    {
        Serial.println("Connecting to MQTT...");
        if (client.connect("ESP32Client"))
        {
            Serial.println("Connected to MQTT");
            client.subscribe("home/testLEDs");
        }
        else
        {
            Serial.print("Failed, rc=");
            Serial.print(client.state());
            delay(5000);
        }
    }
}

// Tests all status LED's, lighting them up for 2 seconds
void testLEDs()
{
    bool buttonState = digitalRead(button); //  Read the button state

    if (buttonState == HIGH && ledTestActive == false) //  If the button is pressed down (HIGH) and LED's are not already turned on
    {
        digitalWrite(ledRedLum, HIGH); //  Turn on all LED's
        digitalWrite(ledRedTemp, HIGH);
        digitalWrite(ledRedHum, HIGH);
        digitalWrite(ledGreenLum, HIGH);
        digitalWrite(ledGreenTemp, HIGH);
        digitalWrite(ledGreenHum, HIGH);

        previousMillisTestActive = millis(); // Store the current time to track the 2-second duration
        ledTestActive = true;                // Set the flag to indicate that LED's are on
    }

    if (ledTestActive && millis() - previousMillisTestActive >= testActive) //  If the LED's have been on for 2 seconds or more, turn them off
    {

        digitalWrite(ledRedLum, LOW); // Turn off all LED's
        digitalWrite(ledRedTemp, LOW);
        digitalWrite(ledRedHum, LOW);
        digitalWrite(ledGreenLum, LOW);
        digitalWrite(ledGreenTemp, LOW);
        digitalWrite(ledGreenHum, LOW);

        // Reset the flag to indicate that LEDs are off
        ledTestActive = false;
    }
}

void testLEDsRemotely()
{
    if (ledTestActive == false) // If the LED's are not already on ( test is already running)
    {
        // Turn on all LEDs
        digitalWrite(ledRedLum, HIGH);
        digitalWrite(ledRedTemp, HIGH);
        digitalWrite(ledRedHum, HIGH);
        digitalWrite(ledGreenLum, HIGH);
        digitalWrite(ledGreenTemp, HIGH);
        digitalWrite(ledGreenHum, HIGH);

        previousMillisTestActive = millis(); // Start the 2-second timer
        ledTestActive = true;                // Set the flag to indicate LED's are on
    }

    // Check if 2 seconds have passed
    if (ledTestActive && millis() - previousMillisTestActive >= testActive)
    {
        // Turn off all LED's after 2 seconds
        digitalWrite(ledRedLum, LOW);
        digitalWrite(ledRedTemp, LOW);
        digitalWrite(ledRedHum, LOW);
        digitalWrite(ledGreenLum, LOW);
        digitalWrite(ledGreenTemp, LOW);
        digitalWrite(ledGreenHum, LOW);

        ledTestActive = false; // Reset the flag
    }
}

// Callback function to handle incoming MQTT messages
void callback(char *topic, byte *payload, unsigned int length)
{
    String message = "";
    for (int i = 0; i < length; i++)
    {
        message += (char)payload[i];
    }

    Serial.print("Message arrived on topic: ");
    Serial.print(topic);
    Serial.print(". Message: ");
    Serial.println(message);

    // Check for the test command from Node-RED
    if (String(topic) == "home/testLEDs" && message == "test")
    {
        // Trigger LED test via MQTT
        testLEDsRemotely();
    }
}

// Read the lightsensor with 5 second intervals
void readLdr()
{
    unsigned long currentMillisLdr = millis();

    if (currentMillisLdr - previousMillisLdr >= intervalLdr)
    {
        lum = analogRead(ldrSensor);
        Serial.print("LDR waarde: ");
        Serial.println(lum);
        Serial.print("ESP32 IP Address: ");
        previousMillisLdr = currentMillisLdr;
    }
}

//  Reads the humidity and temeprature with 5 second intervals
void readDht()
{
    unsigned long currentMillisDht = millis();

    if (currentMillisDht - previousMillisDht >= intervalDht)
    {
        hum = dht.readHumidity();
        temp = dht.readTemperature();

        if (isnan(hum) || isnan(temp))
        {
            Serial.println("Failed to read from DHT sensor!"); // Error message
            return;
        }

        Serial.print("Humidity: ");
        Serial.print(hum);
        Serial.print(" %, Temperature: ");
        Serial.println(temp);
        previousMillisDht = currentMillisDht;
    }
}

// Runs the status LED's
void indicateStatus()
{
    // Humidity indicator
    if (hum >= 85) // Optimal humidity is above 85 percent
    {
        digitalWrite(ledGreenHum, HIGH);
        digitalWrite(ledRedHum, LOW); // Turn off the red LED when green is ON
    }
    else
    {
        digitalWrite(ledGreenHum, LOW); // Turn off the green LED when red is ON
        digitalWrite(ledRedHum, HIGH);
    }

    // Temperature indicator
    if (temp < 19 || temp > 23) // Optimal temperature for mycelium growth is 21°C
    // if (temp < 12 && temp > 16) // Optimal temperature for mushroom growth is 13 to 15°C
    {
        digitalWrite(ledRedTemp, HIGH);
        digitalWrite(ledGreenTemp, LOW);
    }
    else
    {
        digitalWrite(ledGreenTemp, HIGH);
        digitalWrite(ledRedTemp, LOW);
    }

    // Light intensity indicator
    if (lum <= 1500)
    {
        digitalWrite(ledGreenLum, HIGH);
        digitalWrite(ledRedLum, LOW);
    }
    else
    {
        digitalWrite(ledGreenLum, LOW);
        digitalWrite(ledRedLum, HIGH);
    }
}

// void writeToBle()
// {
//     // notify changed value
//     if (deviceConnected)
//     {
//         pSensorCharacteristic1->setValue(String(lum).c_str());
//         pSensorCharacteristic1->notify();
//         delay(30); // bluetooth stack will go into congestion, if too many packets are sent, in 6 hours test i was able to go as low as 3ms

//         pSensorCharacteristic2->setValue(String(temp).c_str());
//         pSensorCharacteristic2->notify();
//         delay(30); // bluetooth stack will go into congestion, if too many packets are sent, in 6 hours test i was able to go as low as 3ms

//         pSensorCharacteristic3->setValue(String(hum).c_str());
//         pSensorCharacteristic3->notify();
//         delay(30); // bluetooth stack will go into congestion, if too many packets are sent, in 6 hours test i was able to go as low as 3ms
//     }
//     // disconnecting
//     if (!deviceConnected && oldDeviceConnected)
//     {
//         Serial.println("Device disconnected.");
//         delay(500);                  // give the bluetooth stack the chance to get things ready
//         pServer->startAdvertising(); // restart advertising
//         Serial.println("Start advertising");
//         oldDeviceConnected = deviceConnected;
//     }
//     // connecting
//     if (deviceConnected && !oldDeviceConnected)
//     {
//         // do stuff here on connecting
//         oldDeviceConnected = deviceConnected;
//         Serial.println("Device Connected");
//     }
// }

// Publish sensor values to MQTT broker
void publishSensorData()
{
    // Publish temperature, humidity, and luminosity to MQTT topics
    if (client.connected())
    {
        client.publish(temperatureTopic, String(temp).c_str());
        client.publish(humidityTopic, String(hum).c_str());
        client.publish(luminosityTopic, String(lum).c_str());
        // Serial.println("Sensor data published to MQTT broker."); // for debugging
    }
}

void setup()
{
    Serial.begin(115200);
    Serial.println("Serial monitor started");
    dht.begin();                     // start the temperature and humidity sensor
    // BLEDevice::init("SensorBoxOne"); // Creates the 'SensorBoxOne' bluetooth device

    // // Create the BLE Server
    // pServer = BLEDevice::createServer();
    // pServer->setCallbacks(new MyServerCallbacks());

    // // Create the BLE Service
    // BLEService *pService = pServer->createService(SERVICE_UUID);

    // // Create BLE Characteristics
    // // 1 for luminosity
    // pSensorCharacteristic1 = pService->createCharacteristic(
    //     SENSOR_CHARACTERISTIC_UUID1,
    //     BLECharacteristic::PROPERTY_READ |
    //         BLECharacteristic::PROPERTY_WRITE |
    //         BLECharacteristic::PROPERTY_NOTIFY |
    //         BLECharacteristic::PROPERTY_INDICATE);
    // // 2 for Temperature
    // pSensorCharacteristic2 = pService->createCharacteristic(
    //     SENSOR_CHARACTERISTIC_UUID2,
    //     BLECharacteristic::PROPERTY_READ |
    //         BLECharacteristic::PROPERTY_WRITE |
    //         BLECharacteristic::PROPERTY_NOTIFY |
    //         BLECharacteristic::PROPERTY_INDICATE);
    // // 3 for Humidity
    // pSensorCharacteristic3 = pService->createCharacteristic(
    //     SENSOR_CHARACTERISTIC_UUID3,
    //     BLECharacteristic::PROPERTY_READ |
    //         BLECharacteristic::PROPERTY_WRITE |
    //         BLECharacteristic::PROPERTY_NOTIFY |
    //         BLECharacteristic::PROPERTY_INDICATE);
    // // 4 for receiving data from webapp
    // pWritableCharacteristic1 = pService->createCharacteristic(
    //     WRITABLE_CHARACTERISTIC_UUID1,
    //     BLECharacteristic::PROPERTY_READ |
    //         BLECharacteristic::PROPERTY_WRITE |
    //         BLECharacteristic::PROPERTY_NOTIFY |
    //         BLECharacteristic::PROPERTY_INDICATE);

    // pWritableCharacteristic1->setCallbacks(new MyCallbacks());

    // // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml
    // // Create a BLE Descriptor
    // pSensorCharacteristic1->addDescriptor(new BLE2902());
    // pSensorCharacteristic2->addDescriptor(new BLE2902());
    // pSensorCharacteristic3->addDescriptor(new BLE2902());
    // pWritableCharacteristic1->addDescriptor(new BLE2902());

    // // Start the service
    // pService->start();

    // // Start advertising
    // BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    // pAdvertising->addServiceUUID(SERVICE_UUID);
    // pAdvertising->setScanResponse(false);
    // pAdvertising->setMinPreferred(0x0); // set value to 0x00 to not advertise this parameter
    // BLEDevice::startAdvertising();
    // Serial.println("Waiting a client connection to notify...");

    // Initialize input/output pins
    pinMode(ledRedLum, OUTPUT);
    pinMode(ledRedTemp, OUTPUT);
    pinMode(ledRedHum, OUTPUT);
    pinMode(ledGreenLum, OUTPUT);
    pinMode(ledGreenTemp, OUTPUT);
    pinMode(ledGreenHum, OUTPUT);

    // Connect to wifi
    connectWifi();

    // Connect to the MQTT Broker
    client.setServer(mqtt_server, 1883); // Set the broker's IP and port
    client.setCallback(callback);
    connectToMQTT(); // Establish connection to MQTT broker

    // Serve the HTML page
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
              { request->send(200, "text/html", html_content); });

    // Serve the sensor data as JSON
    server.on("/sensor", HTTP_GET, [](AsyncWebServerRequest *request)
              {
        String jsonData = "{\"temperature\": " + String(temp) + ", \"humidity\": " + String(hum) + ", \"luminosity\": " + String(lum) + "}";
        request->send(200, "application/json", jsonData); });

    // Start server for over the air updates
    ElegantOTA.begin(&server);
    server.begin();
}

void loop()
{
    readDht();
    readLdr();
    client.loop(); // Ensure MQTT client processes messages
    publishSensorData();
    // writeToBle();
    testLEDs();
    if (ledTestActive == false)
    { // This suspends this function while the LED's are being tested.(Or rather, this function only runs while the LED's are not being tested)
        indicateStatus();
    }
}
